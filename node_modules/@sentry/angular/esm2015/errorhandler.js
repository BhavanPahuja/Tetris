import { HttpErrorResponse } from '@angular/common/http';
import { Inject, Injectable } from '@angular/core';
import * as Sentry from '@sentry/browser';
import { captureException } from '@sentry/browser';
import { addExceptionMechanism } from '@sentry/utils';
import { runOutsideAngular } from './zone';
import * as i0 from "@angular/core";
// https://github.com/angular/angular/blob/master/packages/core/src/util/errors.ts
function tryToUnwrapZonejsError(error) {
    // TODO: once Angular14 is the minimum requirement ERROR_ORIGINAL_ERROR and
    //  getOriginalError from error.ts can be used directly.
    return error && error.ngOriginalError
        ? error.ngOriginalError
        : error;
}
function extractHttpModuleError(error) {
    // The `error` property of http exception can be either an `Error` object, which we can use directly...
    if (error.error instanceof Error) {
        return error.error;
    }
    // ... or an`ErrorEvent`, which can provide us with the message but no stack...
    if (error.error instanceof ErrorEvent && error.error.message) {
        return error.error.message;
    }
    // ...or the request body itself, which we can use as a message instead.
    if (typeof error.error === 'string') {
        return `Server returned code ${error.status} with body "${error.error}"`;
    }
    // If we don't have any detailed information, fallback to the request message itself.
    return error.message;
}
/**
 * Implementation of Angular's ErrorHandler provider that can be used as a drop-in replacement for the stock one.
 */
class SentryErrorHandler {
    constructor(options) {
        this._options = Object.assign({ logErrors: true }, options);
    }
    /**
     * Method called for every value captured through the ErrorHandler
     */
    handleError(error) {
        const extractedError = this._extractError(error) || 'Handled unknown error';
        // Capture handled exception and send it to Sentry.
        const eventId = runOutsideAngular(() => captureException(extractedError, scope => {
            scope.addEventProcessor(event => {
                addExceptionMechanism(event, {
                    type: 'angular',
                    handled: false,
                });
                return event;
            });
            return scope;
        }));
        // When in development mode, log the error to console for immediate feedback.
        if (this._options.logErrors) {
            // eslint-disable-next-line no-console
            console.error(extractedError);
        }
        // Optionally show user dialog to provide details on what happened.
        if (this._options.showDialog) {
            Sentry.showReportDialog(Object.assign(Object.assign({}, this._options.dialogOptions), { eventId }));
        }
    }
    /**
     * Used to pull a desired value that will be used to capture an event out of the raw value captured by ErrorHandler.
     */
    _extractError(error) {
        // Allow custom overrides of extracting function
        if (this._options.extractor) {
            const defaultExtractor = this._defaultExtractor.bind(this);
            return this._options.extractor(error, defaultExtractor);
        }
        return this._defaultExtractor(error);
    }
    /**
     * Default implementation of error extraction that handles default error wrapping, HTTP responses, ErrorEvent and few other known cases.
     */
    _defaultExtractor(errorCandidate) {
        const error = tryToUnwrapZonejsError(errorCandidate);
        // We can handle messages and Error objects directly.
        if (typeof error === 'string' || error instanceof Error) {
            return error;
        }
        // If it's http module error, extract as much information from it as we can.
        if (error instanceof HttpErrorResponse) {
            return extractHttpModuleError(error);
        }
        // Nothing was extracted, fallback to default error message.
        return null;
    }
}
SentryErrorHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function SentryErrorHandler_Factory() { return new SentryErrorHandler(i0.ɵɵinject("errorHandlerOptions")); }, token: SentryErrorHandler, providedIn: "root" });
SentryErrorHandler.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
SentryErrorHandler.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['errorHandlerOptions',] }] }
];
/**
 * Factory function that creates an instance of a preconfigured ErrorHandler provider.
 */
function createErrorHandler(config) {
    return new SentryErrorHandler(config);
}
export { createErrorHandler, SentryErrorHandler };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3JoYW5kbGVyLmpzIiwic291cmNlUm9vdCI6Ii9ob21lL3J1bm5lci93b3JrL3NlbnRyeS1qYXZhc2NyaXB0L3NlbnRyeS1qYXZhc2NyaXB0L3BhY2thZ2VzL2FuZ3VsYXIvc3JjLyIsInNvdXJjZXMiOlsiZXJyb3JoYW5kbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3pELE9BQU8sRUFBdUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4RixPQUFPLEtBQUssTUFBTSxNQUFNLGlCQUFpQixDQUFDO0FBQzFDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV0RCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxRQUFRLENBQUM7O0FBaUIzQyxrRkFBa0Y7QUFDbEYsU0FBUyxzQkFBc0IsQ0FBQyxLQUFjO0lBQzVDLDJFQUEyRTtJQUMzRSx3REFBd0Q7SUFDeEQsT0FBTyxLQUFLLElBQUssS0FBb0MsQ0FBQyxlQUFlO1FBQ25FLENBQUMsQ0FBRSxLQUFvQyxDQUFDLGVBQWU7UUFDdkQsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNaLENBQUM7QUFFRCxTQUFTLHNCQUFzQixDQUFDLEtBQXdCO0lBQ3RELHVHQUF1RztJQUN2RyxJQUFJLEtBQUssQ0FBQyxLQUFLLFlBQVksS0FBSyxFQUFFO1FBQ2hDLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQztLQUNwQjtJQUVELCtFQUErRTtJQUMvRSxJQUFJLEtBQUssQ0FBQyxLQUFLLFlBQVksVUFBVSxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFO1FBQzVELE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7S0FDNUI7SUFFRCx3RUFBd0U7SUFDeEUsSUFBSSxPQUFPLEtB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QGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgRXJyb3JIYW5kbGVyIGFzIEFuZ3VsYXJFcnJvckhhbmRsZXIsIEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgU2VudHJ5IGZyb20gJ0BzZW50cnkvYnJvd3Nlcic7XG5pbXBvcnQgeyBjYXB0dXJlRXhjZXB0aW9uIH0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbmltcG9ydCB7IGFkZEV4Y2VwdGlvbk1lY2hhbmlzbSB9IGZyb20gJ0BzZW50cnkvdXRpbHMnO1xuXG5pbXBvcnQgeyBydW5PdXRzaWRlQW5ndWxhciB9IGZyb20gJy4vem9uZSc7XG5cbi8qKlxuICogT3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgYmVoYXZpb3Igb2YgdGhlIEFuZ3VsYXIgRXJyb3JIYW5kbGVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVycm9ySGFuZGxlck9wdGlvbnMge1xuICBsb2dFcnJvcnM/OiBib29sZWFuO1xuICBzaG93RGlhbG9nPzogYm9vbGVhbjtcbiAgZGlhbG9nT3B0aW9ucz86IFNlbnRyeS5SZXBvcnREaWFsb2dPcHRpb25zO1xuICAvKipcbiAgICogQ3VzdG9tIGltcGxlbWVudGF0aW9uIG9mIGVycm9yIGV4dHJhY3Rpb24gZnJvbSB0aGUgcmF3IHZhbHVlIGNhcHR1cmVkIGJ5IHRoZSBBbmd1bGFyLlxuICAgKiBAcGFyYW0gZXJyb3IgVmFsdWUgY2FwdHVyZWQgYnkgQW5ndWxhcidzIEVycm9ySGFuZGxlciBwcm92aWRlclxuICAgKiBAcGFyYW0gZGVmYXVsdEV4dHJhY3RvciBEZWZhdWx0IGltcGxlbWVudGF0aW9uIHRoYXQgY2FuIGJlIHVzZWQgYXMgdGhlIGZhbGxiYWNrIGluIGNhc2Ugb2YgY3VzdG9tIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBleHRyYWN0b3I/KGVycm9yOiB1bmtub3duLCBkZWZhdWx0RXh0cmFjdG9yOiAoZXJyb3I6IHVua25vd24pID0+IHVua25vd24pOiB1bmtub3duO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2NvcmUvc3JjL3V0aWwvZXJyb3JzLnRzXG5mdW5jdGlvbiB0cnlUb1Vud3JhcFpvbmVqc0Vycm9yKGVycm9yOiB1bmtub3duKTogdW5rbm93biB8IEVycm9yIHtcbiAgLy8gVE9ETzogb25jZSBBbmd1bGFyMTQgaXMgdGhlIG1pbmltdW0gcmVxdWlyZW1lbnQgRVJST1JfT1JJR0lOQUxfRVJST1IgYW5kXG4gIC8vICBnZXRPcmlnaW5hbEVycm9yIGZyb20gZXJyb3IudHMgY2FuIGJlIHVzZWQgZGlyZWN0bHkuXG4gIHJldHVybiBlcnJvciAmJiAoZXJyb3IgYXMgeyBuZ09yaWdpbmFsRXJyb3I6IEVycm9yIH0pLm5nT3JpZ2luYWxFcnJvclxuICAgID8gKGVycm9yIGFzIHsgbmdPcmlnaW5hbEVycm9yOiBFcnJvciB9KS5uZ09yaWdpbmFsRXJyb3JcbiAgICA6IGVycm9yO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SHR0cE1vZHVsZUVycm9yKGVycm9yOiBIdHRwRXJyb3JSZXNwb25zZSk6IHN0cmluZyB8IEVycm9yIHtcbiAgLy8gVGhlIGBlcnJvcmAgcHJvcGVydHkgb2YgaHR0cCBleGNlcHRpb24gY2FuIGJlIGVpdGhlciBhbiBgRXJyb3JgIG9iamVjdCwgd2hpY2ggd2UgY2FuIHVzZSBkaXJlY3RseS4uLlxuICBpZiAoZXJyb3IuZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvci5lcnJvcjtcbiAgfVxuXG4gIC8vIC4uLiBvciBhbmBFcnJvckV2ZW50YCwgd2hpY2ggY2FuIHByb3ZpZGUgdXMgd2l0aCB0aGUgbWVzc2FnZSBidXQgbm8gc3RhY2suLi5cbiAgaWYgKGVycm9yLmVycm9yIGluc3RhbmNlb2YgRXJyb3JFdmVudCAmJiBlcnJvci5lcnJvci5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIGVycm9yLmVycm9yLm1lc3NhZ2U7XG4gIH1cblxuICAvLyAuLi5vciB0aGUgcmVxdWVzdCBib2R5IGl0c2VsZiwgd2hpY2ggd2UgY2FuIHVzZSBhcyBhIG1lc3NhZ2UgaW5zdGVhZC5cbiAgaWYgKHR5cGVvZiBlcnJvci5lcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYFNlcnZlciByZXR1cm5lZCBjb2RlICR7ZXJyb3Iuc3RhdHVzfSB3aXRoIGJvZHkgXCIke2Vycm9yLmVycm9yfVwiYDtcbiAgfVxuXG4gIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IGRldGFpbGVkIGluZm9ybWF0aW9uLCBmYWxsYmFjayB0byB0aGUgcmVxdWVzdCBtZXNzYWdlIGl0c2VsZi5cbiAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG59XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgQW5ndWxhcidzIEVycm9ySGFuZGxlciBwcm92aWRlciB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgdGhlIHN0b2NrIG9uZS5cbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmNsYXNzIFNlbnRyeUVycm9ySGFuZGxlciBpbXBsZW1lbnRzIEFuZ3VsYXJFcnJvckhhbmRsZXIge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX29wdGlvbnM6IEVycm9ySGFuZGxlck9wdGlvbnM7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKEBJbmplY3QoJ2Vycm9ySGFuZGxlck9wdGlvbnMnKSBvcHRpb25zPzogRXJyb3JIYW5kbGVyT3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICBsb2dFcnJvcnM6IHRydWUsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGNhbGxlZCBmb3IgZXZlcnkgdmFsdWUgY2FwdHVyZWQgdGhyb3VnaCB0aGUgRXJyb3JIYW5kbGVyXG4gICAqL1xuICBwdWJsaWMgaGFuZGxlRXJyb3IoZXJyb3I6IHVua25vd24pOiB2b2lkIHtcbiAgICBjb25zdCBleHRyYWN0ZWRFcnJvciA9IHRoaXMuX2V4dHJhY3RFcnJvcihlcnJvcikgfHwgJ0hhbmRsZWQgdW5rbm93biBlcnJvcic7XG5cbiAgICAvLyBDYXB0dXJlIGhhbmRsZWQgZXhjZXB0aW9uIGFuZCBzZW5kIGl0IHRvIFNlbnRyeS5cbiAgICBjb25zdCBldmVudElkID0gcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgIGNhcHR1cmVFeGNlcHRpb24oZXh0cmFjdGVkRXJyb3IsIHNjb3BlID0+IHtcbiAgICAgICAgc2NvcGUuYWRkRXZlbnRQcm9jZXNzb3IoZXZlbnQgPT4ge1xuICAgICAgICAgIGFkZEV4Y2VwdGlvbk1lY2hhbmlzbShldmVudCwge1xuICAgICAgICAgICAgdHlwZTogJ2FuZ3VsYXInLFxuICAgICAgICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICAvLyBXaGVuIGluIGRldmVsb3BtZW50IG1vZGUsIGxvZyB0aGUgZXJyb3IgdG8gY29uc29sZSBmb3IgaW1tZWRpYXRlIGZlZWRiYWNrLlxuICAgIGlmICh0aGlzLl9vcHRpb25zLmxvZ0Vycm9ycykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXh0cmFjdGVkRXJyb3IpO1xuICAgIH1cblxuICAgIC8vIE9wdGlvbmFsbHkgc2hvdyB1c2VyIGRpYWxvZyB0byBwcm92aWRlIGRldGFpbHMgb24gd2hhdCBoYXBwZW5lZC5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zaG93RGlhbG9nKSB7XG4gICAgICBTZW50cnkuc2hvd1JlcG9ydERpYWxvZyh7IC4uLnRoaXMuX29wdGlvbnMuZGlhbG9nT3B0aW9ucywgZXZlbnRJZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBwdWxsIGEgZGVzaXJlZCB2YWx1ZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBjYXB0dXJlIGFuIGV2ZW50IG91dCBvZiB0aGUgcmF3IHZhbHVlIGNhcHR1cmVkIGJ5IEVycm9ySGFuZGxlci5cbiAgICovXG4gIHByb3RlY3RlZCBfZXh0cmFjdEVycm9yKGVycm9yOiB1bmtub3duKTogdW5rbm93biB7XG4gICAgLy8gQWxsb3cgY3VzdG9tIG92ZXJyaWRlcyBvZiBleHRyYWN0aW5nIGZ1bmN0aW9uXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZXh0cmFjdG9yKSB7XG4gICAgICBjb25zdCBkZWZhdWx0RXh0cmFjdG9yID0gdGhpcy5fZGVmYXVsdEV4dHJhY3Rvci5iaW5kKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZXh0cmFjdG9yKGVycm9yLCBkZWZhdWx0RXh0cmFjdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEV4dHJhY3RvcihlcnJvcik7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBlcnJvciBleHRyYWN0aW9uIHRoYXQgaGFuZGxlcyBkZWZhdWx0IGVycm9yIHdyYXBwaW5nLCBIVFRQIHJlc3BvbnNlcywgRXJyb3JFdmVudCBhbmQgZmV3IG90aGVyIGtub3duIGNhc2VzLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9kZWZhdWx0RXh0cmFjdG9yKGVycm9yQ2FuZGlkYXRlOiB1bmtub3duKTogdW5rbm93biB7XG4gICAgY29uc3QgZXJyb3IgPSB0cnlUb1Vud3JhcFpvbmVqc0Vycm9yKGVycm9yQ2FuZGlkYXRlKTtcblxuICAgIC8vIFdlIGNhbiBoYW5kbGUgbWVzc2FnZXMgYW5kIEVycm9yIG9iamVjdHMgZGlyZWN0bHkuXG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIC8vIElmIGl0J3MgaHR0cCBtb2R1bGUgZXJyb3IsIGV4dHJhY3QgYXMgbXVjaCBpbmZvcm1hdGlvbiBmcm9tIGl0IGFzIHdlIGNhbi5cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBIdHRwRXJyb3JSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIGV4dHJhY3RIdHRwTW9kdWxlRXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIE5vdGhpbmcgd2FzIGV4dHJhY3RlZCwgZmFsbGJhY2sgdG8gZGVmYXVsdCBlcnJvciBtZXNzYWdlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBwcmVjb25maWd1cmVkIEVycm9ySGFuZGxlciBwcm92aWRlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JIYW5kbGVyKGNvbmZpZz86IEVycm9ySGFuZGxlck9wdGlvbnMpOiBTZW50cnlFcnJvckhhbmRsZXIge1xuICByZXR1cm4gbmV3IFNlbnRyeUVycm9ySGFuZGxlcihjb25maWcpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFcnJvckhhbmRsZXIsIFNlbnRyeUVycm9ySGFuZGxlciB9O1xuIl19